// Decompiled with JetBrains decompiler
// Type: Microsoft.Phone.Data.ConstraintCollection
// Assembly: Microsoft.Phone.Data.Internal, Version=8.0.0.0, Culture=neutral, PublicKeyToken=24eec0d8c86cda1e
// MVID: 7C603BAB-2692-41A5-9823-E2E1FFE181D1
// Assembly location: C:\Users\Empyreal96\Desktop\WINDOW~1\100~1.150\MICROS~2.CBS\ARM_MI~1.297\windows\System32\MI5246~1.DLL

using Microsoft.Phone.Data.Common;
using Microsoft.Phone.Data.Workaround;
using System;
using System.Diagnostics;
using System.Globalization;

namespace Microsoft.Phone.Data
{
  public sealed class ConstraintCollection : InternalDataCollectionBase
  {
    private readonly DataTable table;
    private readonly ArrayList list = new ArrayList();
    private int defaultNameIndex = 1;
    private CollectionChangeEventHandler onCollectionChanged;
    private Constraint[] delayLoadingConstraints;
    private bool fLoadForeignKeyConstraintsOnly;

    internal ConstraintCollection(DataTable table) => this.table = table;

    protected override ArrayList List => this.list;

    public Constraint this[int index]
    {
      get
      {
        if (index >= 0 && index < this.List.Count)
          return (Constraint) this.List[index];
        throw ExceptionBuilder.ConstraintOutOfRange(index);
      }
    }

    internal DataTable Table => this.table;

    public Constraint this[string name]
    {
      get
      {
        int index = this.InternalIndexOf(name);
        if (index == -2)
          throw ExceptionBuilder.CaseInsensitiveNameConflict(name);
        return index >= 0 ? (Constraint) this.List[index] : (Constraint) null;
      }
    }

    public void Add(Constraint constraint) => this.Add(constraint, true);

    internal void Add(Constraint constraint, bool addUniqueWhenAddingForeign)
    {
      if (constraint == null)
        throw ExceptionBuilder.ArgumentNull(nameof (constraint));
      if (this.FindConstraint(constraint) != null)
        throw ExceptionBuilder.DuplicateConstraint(this.FindConstraint(constraint).ConstraintName);
      if (1 < this.table.NestedParentRelations.Length && !this.AutoGenerated(constraint))
        throw ExceptionBuilder.CantAddConstraintToMultipleNestedTable(this.table.TableName);
      switch (constraint)
      {
        case UniqueConstraint _:
          if (((UniqueConstraint) constraint).bPrimaryKey && this.Table.primaryKey != null)
            throw ExceptionBuilder.AddPrimaryKeyConstraint();
          this.AddUniqueConstraint((UniqueConstraint) constraint);
          break;
        case ForeignKeyConstraint _:
          ForeignKeyConstraint foreignKeyConstraint = (ForeignKeyConstraint) constraint;
          if (addUniqueWhenAddingForeign && foreignKeyConstraint.RelatedTable.Constraints.FindKeyConstraint(foreignKeyConstraint.RelatedColumnsReference) == null)
          {
            if (constraint.ConstraintName.Length == 0)
              constraint.ConstraintName = this.AssignName();
            else
              this.RegisterName(constraint.ConstraintName);
            UniqueConstraint uniqueConstraint = new UniqueConstraint(foreignKeyConstraint.RelatedColumnsReference);
            foreignKeyConstraint.RelatedTable.Constraints.Add((Constraint) uniqueConstraint);
          }
          this.AddForeignKeyConstraint((ForeignKeyConstraint) constraint);
          break;
      }
      this.BaseAdd(constraint);
      this.ArrayAdd(constraint);
      this.OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Add, (object) constraint));
      if (!(constraint is UniqueConstraint) || !((UniqueConstraint) constraint).bPrimaryKey)
        return;
      this.Table.PrimaryKey = ((UniqueConstraint) constraint).ColumnsReference;
    }

    public Constraint Add(string name, DataColumn[] columns, bool primaryKey)
    {
      UniqueConstraint uniqueConstraint = new UniqueConstraint(name, columns);
      this.Add((Constraint) uniqueConstraint);
      if (primaryKey)
        this.Table.PrimaryKey = columns;
      return (Constraint) uniqueConstraint;
    }

    public Constraint Add(string name, DataColumn column, bool primaryKey)
    {
      UniqueConstraint uniqueConstraint = new UniqueConstraint(name, column);
      this.Add((Constraint) uniqueConstraint);
      if (primaryKey)
        this.Table.PrimaryKey = uniqueConstraint.ColumnsReference;
      return (Constraint) uniqueConstraint;
    }

    public Constraint Add(
      string name,
      DataColumn primaryKeyColumn,
      DataColumn foreignKeyColumn)
    {
      ForeignKeyConstraint foreignKeyConstraint = new ForeignKeyConstraint(name, primaryKeyColumn, foreignKeyColumn);
      this.Add((Constraint) foreignKeyConstraint);
      return (Constraint) foreignKeyConstraint;
    }

    public Constraint Add(
      string name,
      DataColumn[] primaryKeyColumns,
      DataColumn[] foreignKeyColumns)
    {
      ForeignKeyConstraint foreignKeyConstraint = new ForeignKeyConstraint(name, primaryKeyColumns, foreignKeyColumns);
      this.Add((Constraint) foreignKeyConstraint);
      return (Constraint) foreignKeyConstraint;
    }

    public void AddRange(Constraint[] constraints)
    {
      if (this.table.fInitInProgress)
      {
        this.delayLoadingConstraints = constraints;
        this.fLoadForeignKeyConstraintsOnly = false;
      }
      else
      {
        if (constraints == null)
          return;
        foreach (Constraint constraint in constraints)
        {
          if (constraint != null)
            this.Add(constraint);
        }
      }
    }

    private void AddUniqueConstraint(UniqueConstraint constraint)
    {
      foreach (DataColumn dataColumn in constraint.ColumnsReference)
      {
        if (dataColumn.Table != this.table)
          throw ExceptionBuilder.ConstraintForeignTable();
      }
      constraint.ConstraintIndexInitialize();
      if (!constraint.CanEnableConstraint())
      {
        constraint.ConstraintIndexClear();
        throw ExceptionBuilder.UniqueConstraintViolation();
      }
    }

    private void AddForeignKeyConstraint(ForeignKeyConstraint constraint)
    {
      if (!constraint.CanEnableConstraint())
        throw ExceptionBuilder.ConstraintParentValues();
      constraint.CheckCanAddToCollection(this);
    }

    private bool AutoGenerated(Constraint constraint) => constraint is ForeignKeyConstraint fk ? XmlTreeGen.AutoGenerated(fk, false) : XmlTreeGen.AutoGenerated((UniqueConstraint) constraint);

    public event CollectionChangeEventHandler CollectionChanged
    {
      add => this.onCollectionChanged += value;
      remove => this.onCollectionChanged -= value;
    }

    private void ArrayAdd(Constraint constraint)
    {
      Debug.Assert(constraint != null, "Attempt to add null constraint to constraint array");
      this.List.Add((object) constraint);
    }

    private void ArrayRemove(Constraint constraint) => this.List.Remove((object) constraint);

    internal string AssignName()
    {
      string str = this.MakeName(this.defaultNameIndex);
      ++this.defaultNameIndex;
      return str;
    }

    private void BaseAdd(Constraint constraint)
    {
      if (constraint == null)
        throw ExceptionBuilder.ArgumentNull(nameof (constraint));
      if (constraint.ConstraintName.Length == 0)
        constraint.ConstraintName = this.AssignName();
      else
        this.RegisterName(constraint.ConstraintName);
      constraint.InCollection = true;
    }

    private void BaseGroupSwitch(
      Constraint[] oldArray,
      int oldLength,
      Constraint[] newArray,
      int newLength)
    {
      int num = 0;
      for (int index1 = 0; index1 < oldLength; ++index1)
      {
        bool flag = false;
        for (int index2 = num; index2 < newLength; ++index2)
        {
          if (oldArray[index1] == newArray[index2])
          {
            if (num == index2)
              ++num;
            flag = true;
            break;
          }
        }
        if (!flag)
        {
          this.BaseRemove(oldArray[index1]);
          this.List.Remove((object) oldArray[index1]);
        }
      }
      for (int index = 0; index < newLength; ++index)
      {
        if (!newArray[index].InCollection)
          this.BaseAdd(newArray[index]);
        this.List.Add((object) newArray[index]);
      }
    }

    private void BaseRemove(Constraint constraint)
    {
      if (constraint == null)
        throw ExceptionBuilder.ArgumentNull(nameof (constraint));
      if (constraint.Table != this.table)
        throw ExceptionBuilder.ConstraintRemoveFailed();
      this.UnregisterName(constraint.ConstraintName);
      constraint.InCollection = false;
      switch (constraint)
      {
        case UniqueConstraint _:
          for (int index = 0; index < this.Table.ChildRelations.Count; ++index)
          {
            DataRelation childRelation = this.Table.ChildRelations[index];
            if (childRelation.ParentKeyConstraint == constraint)
              childRelation.SetParentKeyConstraint((UniqueConstraint) null);
          }
          ((UniqueConstraint) constraint).ConstraintIndexClear();
          break;
        case ForeignKeyConstraint _:
          for (int index = 0; index < this.Table.ParentRelations.Count; ++index)
          {
            DataRelation parentRelation = this.Table.ParentRelations[index];
            if (parentRelation.ChildKeyConstraint == constraint)
              parentRelation.SetChildKeyConstraint((ForeignKeyConstraint) null);
          }
          break;
      }
    }

    public bool CanRemove(Constraint constraint) => this.CanRemove(constraint, false);

    internal bool CanRemove(Constraint constraint, bool fThrowException) => constraint.CanBeRemovedFromCollection(this, fThrowException);

    public void Clear()
    {
      if (this.table != null)
      {
        this.table.PrimaryKey = (DataColumn[]) null;
        for (int index = 0; index < this.table.ParentRelations.Count; ++index)
          this.table.ParentRelations[index].SetChildKeyConstraint((ForeignKeyConstraint) null);
        for (int index = 0; index < this.table.ChildRelations.Count; ++index)
          this.table.ChildRelations[index].SetParentKeyConstraint((UniqueConstraint) null);
      }
      if (this.table.fInitInProgress && this.delayLoadingConstraints != null)
      {
        this.delayLoadingConstraints = (Constraint[]) null;
        this.fLoadForeignKeyConstraintsOnly = false;
      }
      int count = this.List.Count;
      Constraint[] constraintArray = new Constraint[this.List.Count];
      this.List.CopyTo((Array) constraintArray, 0);
      try
      {
        this.BaseGroupSwitch(constraintArray, count, (Constraint[]) null, 0);
      }
      catch (Exception ex)
      {
        if (ADP.IsCatchableOrSecurityExceptionType(ex))
        {
          this.BaseGroupSwitch((Constraint[]) null, 0, constraintArray, count);
          this.List.Clear();
          for (int index = 0; index < count; ++index)
            this.List.Add((object) constraintArray[index]);
        }
        throw;
      }
      this.List.Clear();
      this.OnCollectionChanged(InternalDataCollectionBase.RefreshEventArgs);
    }

    public bool Contains(string name) => this.InternalIndexOf(name) >= 0;

    internal bool Contains(string name, bool caseSensitive)
    {
      if (!caseSensitive)
        return this.Contains(name);
      int index = this.InternalIndexOf(name);
      return index >= 0 && name == ((Constraint) this.List[index]).ConstraintName;
    }

    public void CopyTo(Constraint[] array, int index)
    {
      if (array == null)
        throw ExceptionBuilder.ArgumentNull(nameof (array));
      if (index < 0)
        throw ExceptionBuilder.ArgumentOutOfRange(nameof (index));
      if (array.Length - index < this.list.Count)
        throw ExceptionBuilder.InvalidOffsetLength();
      for (int index1 = 0; index1 < this.list.Count; ++index1)
        array[index + index1] = (Constraint) this.list[index1];
    }

    internal Constraint FindConstraint(Constraint constraint)
    {
      int count = this.List.Count;
      for (int index = 0; index < count; ++index)
      {
        if (((Constraint) this.List[index]).Equals((object) constraint))
          return (Constraint) this.List[index];
      }
      return (Constraint) null;
    }

    internal UniqueConstraint FindKeyConstraint(DataColumn[] columns)
    {
      int count = this.List.Count;
      for (int index = 0; index < count; ++index)
      {
        if (this.List[index] is UniqueConstraint uniqueConstraint1 && ConstraintCollection.CompareArrays(uniqueConstraint1.Key.ColumnsReference, columns))
          return uniqueConstraint1;
      }
      return (UniqueConstraint) null;
    }

    internal UniqueConstraint FindKeyConstraint(DataColumn column)
    {
      int count = this.List.Count;
      for (int index = 0; index < count; ++index)
      {
        if (this.List[index] is UniqueConstraint uniqueConstraint1)
        {
          DataKey key = uniqueConstraint1.Key;
          if (key.ColumnsReference.Length == 1)
          {
            key = uniqueConstraint1.Key;
            if (key.ColumnsReference[0] == column)
              return uniqueConstraint1;
          }
        }
      }
      return (UniqueConstraint) null;
    }

    internal ForeignKeyConstraint FindForeignKeyConstraint(
      DataColumn[] parentColumns,
      DataColumn[] childColumns)
    {
      int count = this.List.Count;
      for (int index = 0; index < count; ++index)
      {
        if (this.List[index] is ForeignKeyConstraint foreignKeyConstraint1)
        {
          DataKey dataKey = foreignKeyConstraint1.ParentKey;
          if (ConstraintCollection.CompareArrays(dataKey.ColumnsReference, parentColumns))
          {
            dataKey = foreignKeyConstraint1.ChildKey;
            if (ConstraintCollection.CompareArrays(dataKey.ColumnsReference, childColumns))
              return foreignKeyConstraint1;
          }
        }
      }
      return (ForeignKeyConstraint) null;
    }

    private static bool CompareArrays(DataColumn[] a1, DataColumn[] a2)
    {
      Debug.Assert(a1 != null && a2 != null, "Invalid Arguments");
      if (a1.Length != a2.Length)
        return false;
      for (int index1 = 0; index1 < a1.Length; ++index1)
      {
        bool flag = false;
        for (int index2 = 0; index2 < a2.Length; ++index2)
        {
          if (a1[index1] == a2[index2])
          {
            flag = true;
            break;
          }
        }
        if (!flag)
          return false;
      }
      return true;
    }

    public int IndexOf(Constraint constraint)
    {
      if (constraint != null)
      {
        int count = this.Count;
        for (int index = 0; index < count; ++index)
        {
          if (constraint == (Constraint) this.List[index])
            return index;
        }
      }
      return -1;
    }

    public int IndexOf(string constraintName)
    {
      int num = this.InternalIndexOf(constraintName);
      return num >= 0 ? num : -1;
    }

    internal int InternalIndexOf(string constraintName)
    {
      int num = -1;
      if (constraintName != null && 0 < constraintName.Length)
      {
        int count = this.List.Count;
        for (int index = 0; index < count; ++index)
        {
          switch (this.NamesEqual(((Constraint) this.List[index]).ConstraintName, constraintName, false, this.table.Locale))
          {
            case -1:
              num = num == -1 ? index : -2;
              break;
            case 1:
              return index;
          }
        }
      }
      return num;
    }

    private string MakeName(int index) => 1 == index ? "Constraint1" : "Constraint" + index.ToString((IFormatProvider) CultureInfo.InvariantCulture);

    private void OnCollectionChanged(CollectionChangeEventArgs ccevent)
    {
      if (this.onCollectionChanged == null)
        return;
      this.onCollectionChanged((object) this, ccevent);
    }

    internal void RegisterName(string name)
    {
      Debug.Assert(name != null);
      int count = this.List.Count;
      for (int index = 0; index < count; ++index)
      {
        if (this.NamesEqual(name, ((Constraint) this.List[index]).ConstraintName, true, this.table.Locale) != 0)
          throw ExceptionBuilder.DuplicateConstraintName(((Constraint) this.List[index]).ConstraintName);
      }
      if (this.NamesEqual(name, this.MakeName(this.defaultNameIndex), true, this.table.Locale) == 0)
        return;
      ++this.defaultNameIndex;
    }

    public void Remove(Constraint constraint)
    {
      if (constraint == null)
        throw ExceptionBuilder.ArgumentNull(nameof (constraint));
      if (!this.CanRemove(constraint, true))
        return;
      this.BaseRemove(constraint);
      this.ArrayRemove(constraint);
      if (constraint is UniqueConstraint && ((UniqueConstraint) constraint).IsPrimaryKey)
        this.Table.PrimaryKey = (DataColumn[]) null;
      this.OnCollectionChanged(new CollectionChangeEventArgs(CollectionChangeAction.Remove, (object) constraint));
    }

    public void RemoveAt(int index) => this.Remove(this[index] ?? throw ExceptionBuilder.ConstraintOutOfRange(index));

    public void Remove(string name) => this.Remove(this[name] ?? throw ExceptionBuilder.ConstraintNotInTheTable(name));

    internal void UnregisterName(string name)
    {
      if (this.NamesEqual(name, this.MakeName(this.defaultNameIndex - 1), true, this.table.Locale) == 0)
        return;
      do
      {
        --this.defaultNameIndex;
      }
      while (this.defaultNameIndex > 1 && !this.Contains(this.MakeName(this.defaultNameIndex - 1)));
    }

    internal void FinishInitConstraints()
    {
      if (this.delayLoadingConstraints == null)
        return;
      for (int index1 = 0; index1 < this.delayLoadingConstraints.Length; ++index1)
      {
        if (this.delayLoadingConstraints[index1] is UniqueConstraint)
        {
          if (!this.fLoadForeignKeyConstraintsOnly)
          {
            UniqueConstraint loadingConstraint = (UniqueConstraint) this.delayLoadingConstraints[index1];
            if (loadingConstraint.columnNames == null)
            {
              this.Add((Constraint) loadingConstraint);
            }
            else
            {
              int length = loadingConstraint.columnNames.Length;
              DataColumn[] columns = new DataColumn[length];
              for (int index2 = 0; index2 < length; ++index2)
                columns[index2] = this.table.Columns[loadingConstraint.columnNames[index2]];
              if (loadingConstraint.bPrimaryKey)
              {
                if (this.table.primaryKey != null)
                  throw ExceptionBuilder.AddPrimaryKeyConstraint();
                this.Add(loadingConstraint.ConstraintName, columns, true);
              }
              else
              {
                UniqueConstraint uniqueConstraint = new UniqueConstraint(loadingConstraint.constraintName, columns);
                if (this.FindConstraint((Constraint) uniqueConstraint) == null)
                  this.Add((Constraint) uniqueConstraint);
              }
            }
          }
        }
        else
        {
          ForeignKeyConstraint loadingConstraint = (ForeignKeyConstraint) this.delayLoadingConstraints[index1];
          if (loadingConstraint.parentColumnNames == null || loadingConstraint.childColumnNames == null)
            this.Add((Constraint) loadingConstraint);
          else if (this.table.DataSet == null)
          {
            this.fLoadForeignKeyConstraintsOnly = true;
          }
          else
          {
            int length = loadingConstraint.parentColumnNames.Length;
            DataColumn[] parentColumns = new DataColumn[length];
            DataColumn[] childColumns = new DataColumn[length];
            for (int index2 = 0; index2 < length; ++index2)
            {
              parentColumns[index2] = loadingConstraint.parentTableNamespace != null ? this.table.DataSet.Tables[loadingConstraint.parentTableName, loadingConstraint.parentTableNamespace].Columns[loadingConstraint.parentColumnNames[index2]] : this.table.DataSet.Tables[loadingConstraint.parentTableName].Columns[loadingConstraint.parentColumnNames[index2]];
              childColumns[index2] = this.table.Columns[loadingConstraint.childColumnNames[index2]];
            }
            this.Add((Constraint) new ForeignKeyConstraint(loadingConstraint.constraintName, parentColumns, childColumns)
            {
              AcceptRejectRule = loadingConstraint.acceptRejectRule,
              DeleteRule = loadingConstraint.deleteRule,
              UpdateRule = loadingConstraint.updateRule
            });
          }
        }
      }
      if (this.fLoadForeignKeyConstraintsOnly)
        return;
      this.delayLoadingConstraints = (Constraint[]) null;
    }
  }
}
